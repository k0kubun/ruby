% # -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*-
% # Copyright (c) 2018 Takashi Kokubun.  All rights reserved.
% #
% # This file is a part of  the programming language Ruby.  Permission is hereby
% # granted, to either  redistribute and/or modify this file,  provided that the
% # conditions mentioned  in the  file COPYING  are met.   Consult the  file for
% # details.
%
% # Moves pc regardless of `handles_frame?` so that next_pc is always different for `pc_sp_offsets`.
        fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
% # Set the offset when next frame is pushed. This will be used to calculate sp on longjmp.
        status->pc_sp_offsets[next_pos] = b->stack_size + <%= insn.call_attribute('sp_inc') %> - <%= insn.rets.size %>;
%
% # sp motion is optimized away for `handles_frame? #=> false` case.
% # Thus sp should be set properly before `goto cancel` or longjmp.
% if insn.handles_frame?
        fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + stack_size + 1 - <%= insn.pops.size %>;\n"); /* POPN(INSN_ATTR(popn)); */
%
%       # JIT-only behavior (pushing JIT's local variables to VM's stack):
        {
            rb_snum_t i, push_size;
            push_size = -<%= insn.call_attribute('sp_inc') %> + <%= insn.rets.size %> - <%= insn.pops.size %>;
            for (i = 0; i < push_size; i++) { /* TODO: use memcpy? */
                fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
            }
        }
% end
